---
title: Day-09 RPC原理与通信 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


# RPC的概述

>在本地去调用远程服务,获取远程物理机上的信息成为RPC,RPC的目的就是能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力，比如服务消费方在执行helloWorldService.sayHello("test")时，实质上调用的是远端的服务。这种方式其实就是RPC（Remote Procedure Call Protocol），在各大互联网公司中被广泛使用，如阿里巴巴的hsf、dubbo（开源）、Facebook的thrift（开源）、Google grpc（开源）、Twitter的finagle（开源）等

## RPC的流程
>1）服务消费方（client）调用以本地调用方式调用服务；

>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；

>3）client stub找到服务地址，并将消息发送到服务端；

>4）server stub收到消息后进行解码；

>5）server stub根据解码结果调用本地的服务；

>6）本地服务执行并将结果返回给server stub；

>7）server stub将返回结果打包成消息并发送至消费方；

>8）client stub接收到消息，并进行解码；

>9）服务消费方得到最终结果。

>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。

![][1]

## 如何封装RPC能像调用本地一样调用远程

>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式

>我们需要实现RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello("test")方法时就会调用invoke方法。

## 序列化

>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。
什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。
为什么需要序列化？转换为二进制串后才好进行网络传输嘛！
为什么需要反序列化？将二进制转换为对象才好进行后续处理！

>从RPC的角度上看，主要看三点：1）通用性，比如是否能支持Map等复杂的数据结构；2）性能，包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；3）可扩展性，对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。

>目前互联网公司广泛使用Protobuf、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案

## 通信:消息数据结构被序列化为二进制串后，下一步就要进行网络通信了

### 目前常用的是NIO和BIO两种通信模式,一般RPC框架都支持这两种通信方式

#### 抽象故事
>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：
1） 顾客填申请表（5分钟）；
2） 职员审核（1分钟）；
3） 职员叫保安去金库取钱（3分钟）；
4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。

#### BIO模式
>每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待,就是日常银行处理事情的方式,一个职员负责一个顾客,没职员了顾客就得等待

#### NIO模式
>如何提高银行的吞吐量呢？
思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。

>可以看到典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。
具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。
mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。

>总的来说就是专人负责专事,根据耗时分配人力,让每个人都不闲着

#### 异步

>NIO+异步的方式能让少量的线程（资源）做大量的事情，这适用于很多应用场景，比如代理服务、api服务、长连接服务等等，这些应用如果用同步方式将耗费大量机器资源。尽管NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。
>从需求来看就是跳表完成后就去做后边的流程,最后在过来完成,期间职员可以让其他人填表,所以会提高整体的吞吐量,而单个用户的等待时间将会有可能拉长

### 发布服务

>zookeeper可以充当一个服务注册表（Service Registry），让多个服务提供者形成一个集群，让服务消费者通过服务注册表获取具体的服务访问地址（ip+端口）去访问具体的服务提供者。
>zookeeper提供了“心跳检测”功能，它会定时向各个服务提供者发送一个请求（实际上建立的是一个 Socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除，比如100.19.20.02这台机器如果宕机了，那么zookeeper上的路径就会只剩/HelloWorldService/1.0.0/100.19.20.01:16888
>服务消费者会去监听相应路径（/HelloWorldService/1.0.0），一旦路径上的数据有任务变化（增加或减少），zookeeper都会通知服务消费方服务提供者地址列表已经发生改变，从而进行更新
>服务消费者会去监听相应路径（/HelloWorldService/1.0.0），一旦路径上的数据有任务变化（增加或减少），zookeeper都会通知服务消费方服务提供者地址列表已经发生改变，从而进行更新

![][2]


  [1]: https://www.github.com/zyzfirst/note_images/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1508327734602.jpg
  [2]: https://www.github.com/zyzfirst/note_images/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1508329417677.jpg